1.알고리즘의 기본 상식
-한정된 자원을 얼마나 아껴쓰는가가 중요
-자원:시간복잡도(CPU)나 공간복잡도(메모리)

CPU가 1초에 수행할 수 있는 일반적인 연산횟수는 1억 번. 보통의 시간 복잡도 분석이나 코딩테스트에서는 이 척도를 사용

N = 데이터의 개수, 내게 주어진 일의 양

**1.$N \le 10$**, 하나하나 전부 해봄(순열) $O(N!)$ 
 계산식: $10\times9\times8\times7.....\times1$  =10!=3628.800번 (약 360만번)

 **2.$N \le 20$** ,각 요소들을 포함시킬지 말지 2가지로 결정(브루트포스/비트마스킹)  $O(2^N)$  
계산식:$2^{20}$ =1,048,576(약 100만번)

**단, 주의점! N이 20을 넘어가면 안됨 

**3.$N \le 500$** for문을 3번 중첩. 세 개씩 짝지어보고 결정함(삼중반복문) 
계산식:$500^3$=125,000,000
(ex)
모든 노드들간의 최단거리를 구하기(i는 출발지, j는 도착지, k는 거쳐가는곳)
충돌 체크: "몬스터 100마리가 서로 부딪히는지 확인하기 ($100 \times 100$)
가장 가까운 적 찾기:플레이어 주변 몬스터 500마리 중 누가 제일 가깝나 다 계산하기

**단, 주의점! 유니티 Update() 함수 안에서 몬스터가 수천 마리가 되면 바로 프레임 드랍이 일어나는 주범**

**4.$N \le 5000$** for문을 2번 중첩. 모든 쌍(i,j) 두 개씩 짝지어보고 결정. $O(N^2)$ 
계산기:$5000^2$ =25,000,000(2500만)
$10000^2$ =100,000,000(1억)
(ex)
-**선택정렬**:가장 작은걸 찾아서 맨 앞으로 보내기
*특징*-데이터 양이 아주 작을 때 사용하지만 이점X)
중요도-(2/10)

-**삽입정렬**:2번째,3번째...앞에서부터 순서대로 자기 자리에 끼워넣음
*장점*-매우 실용적.데이터가 거의 정렬된 상태면 $O(N)$에 가까울 정도로 빠른 속도. 살짝만 틀어진 순서일때 효과적
중요도-(8/10)

-**버블정렬**:옆에 있는거랑 비교해서 큰걸 뒤로 보내는걸 반복
*특징*-실무에선 거의안쓸정도로 거의 비효율적.
중요도-(2/10)

**5.$N \le 1,000,000$** 데이터를 쪼개거나 트리 구조 등을 활용. 효율적인 데이터 처리 $O(N\log N)$ 
(ex)
-**퀵정렬**:기준점(pivot)을 정해 2개의 부분집합으로 분할(Divide)
작은건 왼쪽 큰놈은 오른쪽으로 정렬(정복:Conquer). 부분집합이 더 안나누어질때까지 반복.
*특징*-평균 속도 $O(n\log n)$ 이미 정렬된 데이터처럼 최악 $O(N^2)$ 추가 메모리 $O(log N)$ 
ex)유저 랭킹 집계,아이템 리스트 가격순 정렬 등 일반적인 대량 데이터 정렬.
중요도-(9/10)

-**병합 졍렬**:반으로 쪼갤 수 없을 때까지 쪼갠 후 합치면서 순서를 맞춤
특징- 무조건 속도가 일정해 안정적.
평균 $O(N \log N)$ , 최악 $O(N \log N)$ 추가 메모리 $O(N)$
ex)아이템 등급별 정렬 후,  획득 순서가 바뀌지 않아야 할 때
중요도-(8/10)

-**힙 정렬**:부모가 자식보다 무조건 큰 이진 트리 즉 힙 트리구조를 이용해 최상단(큰 값)을 뽑고 그걸 반복해 일괄로 정렬함

평균 $O(N \log N)$, 최악 $O(N \log N)$ 추가 메모리 $O(1)$
중요도-(7/10)

-**std::sort**:기본인 퀵정렬으로 시작해 힙정렬,삽입정렬으로 유동적으로 변하는 인트로정렬
퀵정렬,힙정렬,삽입정렬이 모두 포함되어있어 사실상 상위호환
데이터 뭉치(배열)을 한번에 줄세울때 사용

평균 $O(N\log N)$ 최악 $O(N\log N)$ 추가 메모리 $O(\log N)$
(algorithm) 헤더 사용

ex)
(1)데이터를 통해 랭킹 보드 산출
(2)그래픽 렌더링에서 거리순으로 그려야 화면이 안깨지기 때문에 오브젝트를 거리순으로 std::sort함
(3)DB 검색을 위한 사전준비
이분탐색을 할때 조건(데이터가 정렬되어 있을것) 이때 사용.



중요도-(10/10) + **매우 중요!!** 

-**우선순위 큐**:힙 트리구조를 사용하지만 미리 정렬해놓는게 아닌 그때그때 필요할때마다 한 놈만 골라놓음. 중요도-(10/10) + **매우 중요!!**
A) 새로운 데이터가 들어왔을 때 (Push)
-새로운 몬스터가 들어왔을때
 1.새 데이터를 힙 트리의 가장 마지막에 배치.
 2.부모와 우선순위 비교를 반복해 최대한 높이 올라갈 때까지 반복

B)가장 중요한 데이터를 뽑고, 다음 놈을 준비시킬 때 (Pop)
-가장 가까운 몬스터가 죽어서 리스트에서 지우면 그다음으로 가까운놈 알아야됨
 1.맨위 노드(루트노드)를 밖으로 빼냄
 2.배열의 맨마지막 노드에 있는 데이터를 루트노드(비어있는 자리)에 넣음
 3.그 데이터의 자식노드 중 우선순위가 더 높은거랑 위치를 바꿈.
 4.이를 반복()

ex) 
(1)**A* 길 찾기 알고리즘**:게임에서 몬스터가 장애물을 피해 플레이어를 찾아오는 가장 똑똑한 방법
실시간 삽입(Push)과 최솟값 추출(Pop)을 무한 반복함 중요도-(10/10) + **매우 중요!!!!**
 1.몬스터가 갈 수 있는 주변 길(노드)들을 전부 조사합니다.
    
 2.각 길마다 (목표까지의 예상 거리) 점수를 매겨서 **우선순위 큐**에 넣음. (**Push**)
    
 3.큐에서 점수가 가장 낮은(가장 유망한) 길 하나를 쏙 뽑아서 거기로 이동. (**Pop**)
    
 4.그 위치에서 다시 주변 길을 조사해서 큐에 넣음.
 
(2)**이벤트 스케줄링**:게임 서버나 엔진에서 "특정 시간 뒤에 실행될 일"들을 관리하는 시스템
시간순 정렬 상태 유지와 최상단 확인(Top/Pop) 사용 중요도-(9/10)
 1.(1.5초 뒤 폭발)(0.5초 후 마나 회복) 등 이벤트들을 발생 시간순으로 **우선순위 큐**에 넣음(Push)
 2.서버는 매 프레임마다 큐의 맨 윗부분(가장 빨리 실행될 일)만 확인(Top)
 3."1.5초 지났네? 폭발해야겠다!" 하면 이벤트를 뽑아서 실행(Pop)


**6.$N \le 10,000,000$** : 1000만개를 $O(N \log N)$으로 계산하면 약 2.4억번이기 때문에 아슬아슬함. 그래서 훑으면서 할 수 밖에 없음. $O(N)$ 

-**카운팅정렬**-비교를 포기하고 훑어보면서 그냥 개수를 셈(1이 몇개지 2는 몇개지) $O(N)$

ex)아이템 종류가 정해진 인벤토리 정리. 예를 들어 메이플스토리 같은 게임에서 소비창의 수많은 아이템을 종류별로 모을 때 사용

중요도-(7/10)

-**투 포인터**-배열의 인덱스를 가리키는 두 개의 변수(left,right or start,end)를 조작해 원하는 조건을 찾음
+한 구간에서 같은 방향으로 출발하거나, 양 끝에서 가운데 방향으로 출발

ex) 리듬게임의 판정 로직. 메모리에 수만개의 노트가 시간순으로 정렬되어있고 매 프레임마다 [현재 시간 - 판정 오차] 와 [현재 시간 + 판정 오차] 사이의 노트를 체크해야됨. 이 때 사용

중요도-(9/10)

**7.$N > 10^9$(10억)**   $O(log N)$ 중요도-(10/10) **둘 다 매우 중요!!**
-데이터가 과도하게 많기 때문에 하나하나 확인하지않고 **이분탐색**이나 **해시 테이블**처럼 버리는 기술을 많이 사용.

-**이분탐색(Binary Search)** : **데이터가 정렬되어 있다는 조건하에** 중간값을 찍은후 정답이 없는 쪽을 통째로 버림.
중요도:10/10
성능-10억 개 중 단 하나를 찾는데 30번($log_2 10^9$ $\approx$ 30)만 비교하면 됨

활용-수만 개의 레벨이 담긴 경험치 테이블에서 내 경험치에 맞는 레벨을 찾아내거나 전세계의 유저 DB에서 특정 유저를 찾을 때 사용함

-**해시테이블(Hash Table)**:키(Key) 값을 넣으면 수학적 계산으로 데이터가 있는 주소로 바로 점프

성능:데이터 양과 상관없이 평균적으로 $O(1)$임. 100억개가 있어도 단 한번에 찾아냄

활용:수만 개의 텍스처나 사운드 리소스 중 이름만으로 파일을 즉시 로드할 때, 혹은 온라인 게임에서 아이템 Id로 정보를 바로 불러올때 사용
